/* Generated by RuntimeBrowser
   Image: /System/Library/Frameworks/PencilKit.framework/PencilKit
 */

@interface PKStrokeGenerator : NSObject <PKInputProvider> {
    double  _additionalRollAngle;
    NSArray * _allInputPointFilters;
    bool  _alwaysUseRollAngleForFountainPen;
    void * _animationFilter;
    void * _azimuthFilter;
    double  _baseRollAngle;
    struct os_unfair_lock_s { 
        unsigned int _os_unfair_lock_opaque; 
    }  _baseRollAngleLock;
    struct _PKStrokePoint { 
        double timestamp; 
        struct CGPoint { 
            double x; 
            double y; 
        } location; 
        double radius; 
        double aspectRatio; 
        double edgeWidth; 
        double force; 
        double azimuth; 
        double altitude; 
        double opacity; 
        double radius2; 
    }  _baseValues;
    bool  _canSnapToRuler;
    bool  _captureLiveData;
    void * _compressionFilter;
    unsigned long long  _currentActiveInputProperties;
    double  _currentAdditionalRollAngle;
    double  _currentBaseRollAngle;
    long long  _currentInputType;
    bool  _currentRollAngleEnabled;
    bool  _currentShouldClearAzimuth;
    PKStroke * _currentStroke;
    double  _currentStrokeRollBaseValue;
    double  _currentStrokeRollDeltaMax;
    double  _currentStrokeRollDeltaMin;
    void * _decompressionFilter;
    <PKStrokeGeneratorDelegate> * _delegate;
    void * _directionAngleFilter;
    struct vector<PKInputPoint, std::allocator<PKInputPoint>> { 
        struct { /* ? */ } *__begin_; 
        struct { /* ? */ } *__end_; 
        struct __compressed_pair<PKInputPoint *, std::allocator<PKInputPoint>> { 
            struct { /* ? */ } *__value_; 
        } __end_cap_; 
    }  _drawPoints;
    bool  _drawingEndedButNotFinished;
    NSObject<OS_dispatch_semaphore> * _drawingWaitForFinishSemaphore;
    bool  _enableDidUpdateRoll;
    void * _endCapFilter;
    void * _endHookFilter;
    double  _eraserIndicatorAlpha;
    void * _estimatedAltitudeAndAzimuthFilter;
    PKInputPointExtraRollLatencyFilter * _extraRollLatencyFilter;
    void * _fountainPenFilter;
    long long  _immutableCount;
    bool  _inputHasChanged;
    void * _inputProvider;
    NSObject<OS_dispatch_queue> * _inputQueue;
    double  _inputScale;
    void * _inputSmoother;
    void * _inputToOutputFilter;
    bool  _isPreviewing;
    bool  _isSnappedToRuler;
    bool  _isSnappedToRulerTopSide;
    bool  _keepPredictedTouchesAtEndOfStroke;
    struct CGPoint { 
        double x; 
        double y; 
    }  _lastPoint;
    double  _latestNonPredictedTimestamp;
    long long  _missedUpdates;
    void * _noiseSmoother;
    long long  _outputImmutableCount;
    struct vector<_PKStrokePoint, std::allocator<_PKStrokePoint>> { 
        struct _PKStrokePoint {} *__begin_; 
        struct _PKStrokePoint {} *__end_; 
        struct __compressed_pair<_PKStrokePoint *, std::allocator<_PKStrokePoint>> { 
            struct _PKStrokePoint {} *__value_; 
        } __end_cap_; 
    }  _outputPoints;
    NSObject<OS_dispatch_queue> * _outputQueue;
    void * _pixelSmoothingFilter;
    void * _pointReductionFilter;
    void * _propertySmoother;
    bool  _rollAngleEnabled;
    PKInputPointRollNoiseFilter * _rollNoiseFilter;
    void * _rulerExtremaFilter;
    struct CGAffineTransform { 
        double a; 
        double b; 
        double c; 
        double d; 
        double tx; 
        double ty; 
    }  _rulerTransform;
    double  _rulerWidth;
    bool  _shouldClearAzimuth;
    bool  _shouldSetIsSafeForStyleInventorFlag;
    void * _startCapFilter;
    void * _startHookFilter;
    double  _strokeMaxForce;
    double  _touchSensitivity;
    struct vector<PKInputPoint, std::allocator<PKInputPoint>> { 
        struct { /* ? */ } *__begin_; 
        struct { /* ? */ } *__end_; 
        struct __compressed_pair<PKInputPoint *, std::allocator<PKInputPoint>> { 
            struct { /* ? */ } *__value_; 
        } __end_cap_; 
    }  _updatedDrawPoints;
    bool  _useRuler;
    void * _velocityFilter;
}

@property (nonatomic, readonly) unsigned long long activeInputProperties;
@property double additionalRollAngle;
@property (nonatomic) void*animationFilter;
@property (nonatomic) void*azimuthFilter;
@property (nonatomic) bool canSnapToRuler;
@property (nonatomic) bool captureLiveData;
@property (nonatomic) void*compressionFilter;
@property (nonatomic) void*decompressionFilter;
@property (nonatomic) <PKStrokeGeneratorDelegate> *delegate;
@property (nonatomic) void*directionAngleFilter;
@property (nonatomic) void*endCapFilter;
@property (nonatomic) void*endHookFilter;
@property double eraserIndicatorAlpha;
@property (nonatomic) void*estimatedAltitudeAndAzimuthFilter;
@property (nonatomic) void*fountainPenFilter;
@property (nonatomic) void*inputProvider;
@property (nonatomic) double inputScale;
@property (nonatomic) void*inputSmoother;
@property (nonatomic) void*inputToOutputFilter;
@property (nonatomic, readonly) long long inputType;
@property (nonatomic) bool isPreviewing;
@property bool isSnappedToRuler;
@property (nonatomic) bool isSnappedToRulerTopSide;
@property struct CGPoint { double x1; double x2; } lastPoint;
@property (readonly) bool lastPointIsMasked;
@property (nonatomic) void*noiseSmoother;
@property (nonatomic, retain) NSObject<OS_dispatch_queue> *outputQueue;
@property (nonatomic) void*pixelSmoothingFilter;
@property (nonatomic) void*pointReductionFilter;
@property (nonatomic) void*propertySmoother;
@property bool rollAngleEnabled;
@property (nonatomic) void*rulerExtremaFilter;
@property (nonatomic) struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; } rulerTransform;
@property (nonatomic) double rulerWidth;
@property bool shouldClearAzimuth;
@property (nonatomic) void*startCapFilter;
@property (nonatomic) void*startHookFilter;
@property (nonatomic) double strokeMaxForce;
@property (nonatomic) double touchSensitivity;
@property (nonatomic) bool useRuler;
@property (nonatomic) void*velocityFilter;

+ (void)initialize;
+ (struct vector<PKInputPoint, std::allocator<PKInputPoint>> { struct { /* ? */ } *x1; struct { /* ? */ } *x2; struct __compressed_pair<PKInputPoint *, std::allocator<PKInputPoint>> { struct { /* ? */ } *x_3_1_1; } x3; })inputPointsFromPath:(struct CGPath { }*)arg1 maxSegmentLength:(double)arg2 velocityForDistanceFunction:(id /* block */)arg3;
+ (struct vector<PKInputPoint, std::allocator<PKInputPoint>> { struct { /* ? */ } *x1; struct { /* ? */ } *x2; struct __compressed_pair<PKInputPoint *, std::allocator<PKInputPoint>> { struct { /* ? */ } *x_3_1_1; } x3; })inputPointsFromPoints:(const void*)arg1 velocityForDistanceFunction:(id /* block */)arg2;

- (id).cxx_construct;
- (void).cxx_destruct;
- (void)_drawingAddPoint:(struct { union { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_1_1_1; struct CGPoint { double x_2_2_1; double x_2_2_2; } x_1_1_2; } x1; double x2; double x3; double x4; double x5; double x6; double x7; double x8; bool x9; long long x10; double x11; bool x12; double x13; long long x14; long long x15; })arg1;
- (void)_drawingUpdateAllPointsDidTimeout:(bool)arg1 updateSemaphore:(bool)arg2;
- (void)_drawingUpdateAllPointsDidTimeoutWithStrokeUUID:(id)arg1;
- (struct _PKStrokePoint { double x1; struct CGPoint { double x_2_1_1; double x_2_1_2; } x2; double x3; double x4; double x5; double x6; double x7; double x8; double x9; double x10; })_latestStrokePoint;
- (id)_newStrokeWithCurrentDataAndStrokeDataUUID:(id)arg1;
- (void)_removePredictedTouches;
- (void)_updatePredictedTouches;
- (unsigned long long)activeInputProperties;
- (void)addPoint:(struct { union { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_1_1_1; struct CGPoint { double x_2_2_1; double x_2_2_2; } x_1_1_2; } x1; double x2; double x3; double x4; double x5; double x6; double x7; double x8; bool x9; long long x10; double x11; bool x12; double x13; long long x14; long long x15; })arg1;
- (void)addPoints:(struct vector<PKInputPoint, std::allocator<PKInputPoint>> { struct { /* ? */ } *x1; struct { /* ? */ } *x2; struct __compressed_pair<PKInputPoint *, std::allocator<PKInputPoint>> { struct { /* ? */ } *x_3_1_1; } x3; })arg1;
- (double)additionalRollAngle;
- (void)allowSnappingToRuler:(struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })arg1 width:(double)arg2;
- (void*)animationFilter;
- (void*)azimuthFilter;
- (bool)canSnapToRuler;
- (bool)captureLiveData;
- (void)closeStroke;
- (void*)compressionFilter;
- (void)configureFilters;
- (unsigned long long)copyInputUpdatedRangeFromIndex:(unsigned long long)arg1 into:(void*)arg2;
- (void)dealloc;
- (void*)decompressionFilter;
- (id)delegate;
- (void*)directionAngleFilter;
- (double)distanceToRulerCenter:(struct CGPoint { double x1; double x2; })arg1;
- (void)drawingBeganWithStroke:(id)arg1 inputType:(long long)arg2 activeInputProperties:(unsigned long long)arg3 inputScale:(double)arg4 start:(id /* block */)arg5;
- (void)drawingCancelledWithCompletion:(id /* block */)arg1;
- (void)drawingEndedEstimatesTimeout:(double)arg1 completion:(id /* block */)arg2;
- (void)drawingUpdateAllPoints;
- (void)drawingUpdateAllPointsDidTimeoutWithStrokeUUID:(id)arg1;
- (void)drawingUpdatePoint:(struct { union { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_1_1_1; struct CGPoint { double x_2_2_1; double x_2_2_2; } x_1_1_2; } x1; double x2; double x3; double x4; double x5; double x6; double x7; double x8; bool x9; long long x10; double x11; bool x12; double x13; long long x14; long long x15; })arg1;
- (void*)endCapFilter;
- (void*)endHookFilter;
- (double)eraserIndicatorAlpha;
- (void*)estimatedAltitudeAndAzimuthFilter;
- (long long)fetchFilteredPointsFromIndex:(long long)arg1 accessBlock:(id /* block */)arg2;
- (void*)fountainPenFilter;
- (void*)getInputUpdatedRangeFromIndex:(inout unsigned long long*)arg1;
- (struct CGPoint { double x1; double x2; })getRulerSnapLineOriginAndTangent:(struct CGPoint { double x1; double x2; }*)arg1 andNormal:(struct CGPoint { double x1; double x2; }*)arg2;
- (void*)getUpdatedRangeFromIndex:(inout unsigned long long*)arg1;
- (id)init;
- (id)initWithStrokeNoiseSmoothing:(bool)arg1;
- (void*)inputProvider;
- (double)inputScale;
- (void*)inputSmoother;
- (void*)inputToOutputFilter;
- (long long)inputType;
- (bool)isPreviewing;
- (bool)isSnappedToRuler;
- (bool)isSnappedToRulerTopSide;
- (struct CGPoint { double x1; double x2; })lastPoint;
- (bool)lastPointIsMasked;
- (double)latestNonPredictedTimestamp;
- (double)latestTimestamp;
- (void)maskToRuler;
- (id)newStrokeWithCurrentData;
- (id)newStrokeWithCurrentDataCopy;
- (void*)noiseSmoother;
- (struct _PKStrokePoint { double x1; struct CGPoint { double x_2_1_1; double x_2_1_2; } x2; double x3; double x4; double x5; double x6; double x7; double x8; double x9; double x10; })outputCurrentStrokePoint:(struct { union { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_1_1_1; struct CGPoint { double x_2_2_1; double x_2_2_2; } x_1_1_2; } x1; double x2; double x3; double x4; double x5; double x6; double x7; double x8; bool x9; long long x10; double x11; bool x12; double x13; long long x14; long long x15; })arg1;
- (void*)outputFilter;
- (struct _PKStrokePoint { double x1; struct CGPoint { double x_2_1_1; double x_2_1_2; } x2; double x3; double x4; double x5; double x6; double x7; double x8; double x9; double x10; })outputPoint:(struct { union { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_1_1_1; struct CGPoint { double x_2_2_1; double x_2_2_2; } x_1_1_2; } x1; double x2; double x3; double x4; double x5; double x6; double x7; double x8; bool x9; long long x10; double x11; bool x12; double x13; long long x14; long long x15; })arg1 baseValues:(struct _PKStrokePoint { double x1; struct CGPoint { double x_2_1_1; double x_2_1_2; } x2; double x3; double x4; double x5; double x6; double x7; double x8; double x9; double x10; })arg2;
- (id)outputQueue;
- (void*)pixelSmoothingFilter;
- (void*)pointReductionFilter;
- (void*)propertySmoother;
- (void)reset;
- (void)resetFilters;
- (bool)rollAngleEnabled;
- (void*)rulerExtremaFilter;
- (struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })rulerTransform;
- (double)rulerWidth;
- (void)setAdditionalRollAngle:(double)arg1;
- (void)setAnimationFilter:(void*)arg1;
- (void)setAzimuthFilter:(void*)arg1;
- (void)setCanSnapToRuler:(bool)arg1;
- (void)setCaptureLiveData:(bool)arg1;
- (void)setCompressionFilter:(void*)arg1;
- (void)setDecompressionFilter:(void*)arg1;
- (void)setDelegate:(id)arg1;
- (void)setDirectionAngleFilter:(void*)arg1;
- (void)setEndCapFilter:(void*)arg1;
- (void)setEndHookFilter:(void*)arg1;
- (void)setEraserIndicatorAlpha:(double)arg1;
- (void)setEstimatedAltitudeAndAzimuthFilter:(void*)arg1;
- (void)setFountainPenFilter:(void*)arg1;
- (void)setInputProvider:(void*)arg1;
- (void)setInputScale:(double)arg1;
- (void)setInputSmoother:(void*)arg1;
- (void)setInputToOutputFilter:(void*)arg1;
- (void)setIsPreviewing:(bool)arg1;
- (void)setIsSnappedToRuler:(bool)arg1;
- (void)setIsSnappedToRulerTopSide:(bool)arg1;
- (void)setLastPoint:(struct CGPoint { double x1; double x2; })arg1;
- (void)setNoiseSmoother:(void*)arg1;
- (void)setOutputQueue:(id)arg1;
- (void)setPixelSmoothingFilter:(void*)arg1;
- (void)setPointReductionFilter:(void*)arg1;
- (void)setPropertySmoother:(void*)arg1;
- (void)setRollAngleEnabled:(bool)arg1;
- (void)setRulerExtremaFilter:(void*)arg1;
- (void)setRulerTransform:(struct CGAffineTransform { double x1; double x2; double x3; double x4; double x5; double x6; })arg1;
- (void)setRulerWidth:(double)arg1;
- (void)setShouldClearAzimuth:(bool)arg1;
- (void)setStartCapFilter:(void*)arg1;
- (void)setStartHookFilter:(void*)arg1;
- (void)setStrokeMaxForce:(double)arg1;
- (void)setTouchSensitivity:(double)arg1;
- (void)setUseRuler:(bool)arg1;
- (void)setVelocityFilter:(void*)arg1;
- (void)setupForInk:(id)arg1 maximumSupportedContentVersion:(long long)arg2;
- (bool)shouldClearAzimuth;
- (bool)shouldSnapPointToRuler:(struct CGPoint { double x1; double x2; })arg1;
- (struct CGPoint { double x1; double x2; })snapPointToRuler:(struct CGPoint { double x1; double x2; })arg1;
- (void)snapToRuler;
- (void*)startCapFilter;
- (void*)startHookFilter;
- (id)strokeFromInputPoints:(void*)arg1 inputType:(long long)arg2 ink:(id)arg3 inputScale:(double)arg4 randomSeed:(unsigned int)arg5 strokeClass:(Class)arg6;
- (id)strokeFromLineSegments:(const void*)arg1 maxSegmentLength:(double)arg2 ink:(id)arg3 inputScale:(double)arg4 strokeClass:(Class)arg5;
- (id)strokeFromPath:(struct CGPath { }*)arg1 ink:(id)arg2 inputScale:(double)arg3 maxSegmentLength:(double)arg4 velocityForDistanceFunction:(id /* block */)arg5 strokeClass:(Class)arg6;
- (id)strokeFromPoints:(struct CGPoint { double x1; double x2; }*)arg1 count:(unsigned long long)arg2 ink:(id)arg3 inputScale:(double)arg4 strokeClass:(Class)arg5;
- (id)strokeFromPoints:(const void*)arg1 sourceStroke:(id)arg2 inputScale:(double)arg3 averageInputPoint:(struct { union { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_1_1_1; struct CGPoint { double x_2_2_1; double x_2_2_2; } x_1_1_2; } x1; double x2; double x3; double x4; double x5; double x6; double x7; double x8; bool x9; long long x10; double x11; bool x12; double x13; long long x14; long long x15; })arg4;
- (double)strokeMaxForce;
- (double)touchSensitivity;
- (void)updateImmutableCount;
- (void)updateRulerSnapping;
- (bool)useRuler;
- (void*)velocityFilter;
- (void)whenFinishedProcessingPointsCallCompletion:(id /* block */)arg1;

@end
