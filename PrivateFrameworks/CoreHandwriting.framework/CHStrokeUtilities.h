/* Generated by RuntimeBrowser
   Image: /System/Library/PrivateFrameworks/CoreHandwriting.framework/CoreHandwriting
 */

@interface CHStrokeUtilities : NSObject

+ (double)arcLengthForStroke:(id)arg1;
+ (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })boundingBoxOfPoints:(const void*)arg1 rotatedAroundPoint:(struct CGPoint { double x1; double x2; })arg2 byAngle:(double)arg3;
+ (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })boundsForStrokes:(id)arg1;
+ (double)circumferenceRatioOfCircleFittedToPoints:(const void*)arg1 circleCenter:(struct CGPoint { double x1; double x2; }*)arg2 circleRadius:(double*)arg3;
+ (struct vector<CGPoint, std::allocator<CGPoint>> { struct CGPoint {} *x1; struct CGPoint {} *x2; struct __compressed_pair<CGPoint *, std::allocator<CGPoint>> { struct CGPoint {} *x_3_1_1; } x3; })convexHullForPoints:(void*)arg1;
+ (struct vector<CGPoint, std::allocator<CGPoint>> { struct CGPoint {} *x1; struct CGPoint {} *x2; struct __compressed_pair<CGPoint *, std::allocator<CGPoint>> { struct CGPoint {} *x_3_1_1; } x3; })convexHullForStroke:(id)arg1;
+ (struct vector<CGPoint, std::allocator<CGPoint>> { struct CGPoint {} *x1; struct CGPoint {} *x2; struct __compressed_pair<CGPoint *, std::allocator<CGPoint>> { struct CGPoint {} *x_3_1_1; } x3; })convexHullForStrokes:(id)arg1;
+ (struct vector<CGPoint, std::allocator<CGPoint>> { struct CGPoint {} *x1; struct CGPoint {} *x2; struct __compressed_pair<CGPoint *, std::allocator<CGPoint>> { struct CGPoint {} *x_3_1_1; } x3; })convexHullForStrokes:(id)arg1 inDrawing:(id)arg2;
+ (id)createDrawingForStrokeIdentifiers:(id)arg1 strokeProvider:(id)arg2 interpolationType:(long long)arg3 resolution:(long long)arg4 cancellationBlock:(id /* block */)arg5;
+ (id)createDrawingForStrokes:(id)arg1 interpolationType:(long long)arg2 resolution:(long long)arg3 cancellationBlock:(id /* block */)arg4;
+ (id)defaultScriptClassificationDictionary;
+ (double)distanceFromPoint:(struct CGPoint { double x1; double x2; })arg1 toRectangle:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg2;
+ (double)distanceFromPoint:(struct CGPoint { double x1; double x2; })arg1 toSegmentFromPoint:(struct CGPoint { double x1; double x2; })arg2 toPoint:(struct CGPoint { double x1; double x2; })arg3;
+ (double)distanceFromPoint:(struct CGPoint { double x1; double x2; })arg1 toStroke:(id)arg2 withStrokeProvider:(id)arg3;
+ (double)distanceFromPoint:(struct CGPoint { double x1; double x2; })arg1 toStrokes:(id)arg2 withStrokeProvider:(id)arg3;
+ (double)distanceFromRectangle:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg1 toRectangle:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg2;
+ (double)durationOfStrokesInStrokeGroup:(id)arg1 strokeProvider:(id)arg2;
+ (id)encodedStrokeIdentifiers:(id)arg1 withStrokeProvider:(id)arg2;
+ (id)encodedStrokeIdentifiersFromStrokes:(id)arg1 withStrokeProvider:(id)arg2 shouldCancel:(id /* block */)arg3;
+ (struct vector<CGPoint, std::allocator<CGPoint>> { struct CGPoint {} *x1; struct CGPoint {} *x2; struct __compressed_pair<CGPoint *, std::allocator<CGPoint>> { struct CGPoint {} *x_3_1_1; } x3; })enlargedConvexHull:(const void*)arg1 withMargin:(double)arg2;
+ (void)enumeratePointsForStroke:(id)arg1 interpolationType:(long long)arg2 resolution:(long long)arg3 usingBlock:(id /* block */)arg4;
+ (void)getAddedStrokes:(id*)arg1 removedStrokeIdentifiers:(id*)arg2 inStrokeProvider:(id)arg3 lastGroupingResult:(id)arg4 shouldCancel:(id /* block */)arg5;
+ (double)horizontalDistanceBetweenRectangle:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg1 rectangle:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg2;
+ (double)horizontalOverlapOfIndividualStrokeBounds:(const void*)arg1 otherStrokeBounds:(const void*)arg2;
+ (struct vector<CGRect, std::allocator<CGRect>> { struct CGRect {} *x1; struct CGRect {} *x2; struct __compressed_pair<CGRect *, std::allocator<CGRect>> { struct CGRect {} *x_3_1_1; } x3; })horizontallyOverlappedChunks:(const void*)arg1;
+ (bool)isMatchingStrokeClassification:(long long)arg1 scriptClassification:(long long)arg2;
+ (bool)isPointEnumerationSupportedForStroke:(id)arg1;
+ (bool)isScriptClassificationMath:(long long)arg1;
+ (bool)isStroke:(id)arg1 intersectingAnyPolygonInSet:(id)arg2;
+ (bool)isStroke:(id)arg1 intersectingPolygon:(id)arg2;
+ (bool)isStrokeClassificationMath:(long long)arg1;
+ (bool)isStrokeClassificationText:(long long)arg1;
+ (bool)isStrokeClassificationTextOrMath:(long long)arg1;
+ (bool)isStrokeGroup:(id)arg1 inlineWithNextGroup:(id)arg2;
+ (double)lineOrientationForStrokePoints:(const void*)arg1 error:(double*)arg2;
+ (bool)linearScratchOutTestForPoints:(const void*)arg1 direction:(const struct CGVector { double x1; double x2; }*)arg2 origin:(const struct CGPoint { double x1; double x2; }*)arg3 threshold:(float)arg4 cutIndex:(long long*)arg5;
+ (bool)linearScratchOutTestForPoints:(const void*)arg1 threshold:(float)arg2 cutIndex:(long long*)arg3;
+ (long long)minRectangleDistanceFromStrokes:(id)arg1 toPolygons:(id)arg2;
+ (id)polygonForStrokes:(id)arg1;
+ (id)polygonSetForScratchOutStroke:(id)arg1;
+ (void)principalComponentsForPoints:(const void*)arg1 outFirstComponent:(struct CGVector { double x1; double x2; }*)arg2 outSecondComponent:(struct CGVector { double x1; double x2; }*)arg3 outMeanPoint:(struct CGPoint { double x1; double x2; }*)arg4;
+ (struct vector<float, std::allocator<float>> { float *x1; float *x2; struct __compressed_pair<float *, std::allocator<float>> { float *x_3_1_1; } x3; })projectionForPoints:(const void*)arg1 direction:(const struct CGVector { double x1; double x2; }*)arg2 origin:(const struct CGPoint { double x1; double x2; }*)arg3;
+ (struct vector<CGPoint, std::allocator<CGPoint>> { struct CGPoint {} *x1; struct CGPoint {} *x2; struct __compressed_pair<CGPoint *, std::allocator<CGPoint>> { struct CGPoint {} *x_3_1_1; } x3; })regularizedPathFromPoints:(const void*)arg1 delta:(double)arg2 gamma:(double)arg3 outError:(double*)arg4;
+ (id)scriptClassificationClasses;
+ (struct vector<_NSRange, std::allocator<_NSRange>> { struct _NSRange {} *x1; struct _NSRange {} *x2; struct __compressed_pair<_NSRange *, std::allocator<_NSRange>> { struct _NSRange {} *x_3_1_1; } x3; })segmentationRangesForScratchOutPoints:(const void*)arg1;
+ (id)sortedStrokesForIdentifiers:(id)arg1 inStrokeProvider:(id)arg2;
+ (double)speedForFinalTimeRange:(double)arg1 stroke:(id)arg2;
+ (id)strokeForIdentifier:(id)arg1 inStrokeProvider:(id)arg2;
+ (id)strokeIdentifiersByStrokeClusterPolygonsFromStrokeBounds:(id)arg1 strokes:(id)arg2;
+ (id)strokeIdentifiersForData:(id)arg1 withStrokeProvider:(id)arg2;
+ (id)strokesForIdentifiers:(id)arg1 inStrokeProvider:(id)arg2;
+ (id)strokesIntersectingPolygons:(id)arg1 fromStrokes:(id)arg2 intersectedPolygons:(id*)arg3;
+ (double)threePointsOrientationWithOrigin:(struct CGPoint { double x1; double x2; })arg1 pointA:(struct CGPoint { double x1; double x2; })arg2 pointB:(struct CGPoint { double x1; double x2; })arg3;
+ (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })unionStrokeBounds:(const void*)arg1 aroundXPosition:(double)arg2 usingOneSideStrokeCountLimit:(long long)arg3;
+ (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })unionStrokeBounds:(const void*)arg1 usingStrokeCountLimit:(long long)arg2 reverseOrder:(bool)arg3;
+ (double)vectorMeanWithoutOutliers:(void*)arg1;
+ (double)verticalDistanceBetweenRectangle:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg1 rectangle:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg2;

@end
