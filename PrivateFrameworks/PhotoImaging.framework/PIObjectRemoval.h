/* Generated by RuntimeBrowser
   Image: /System/Library/PrivateFrameworks/PhotoImaging.framework/PhotoImaging
 */

@interface PIObjectRemoval : NSObject

+ (id)_instancesForOperation:(id)arg1;
+ (id)_instancesFromMaskIdentifier:(id)arg1;
+ (bool)_loadAndRegisterModelForKey:(id)arg1 error:(out id*)arg2;
+ (id)_maskSourceWithIdentifier:(id)arg1 composition:(id)arg2;
+ (id)_newMaskForInstance:(unsigned long long)arg1 context:(id)arg2 maskIdentifier:(id)arg3 error:(out id*)arg4;
+ (id)_newMaskForInstances:(id)arg1 context:(id)arg2 maskIdentifier:(id)arg3 error:(out id*)arg4;
+ (id)_newMaskImageForOperation:(id)arg1 composition:(id)arg2 error:(out id*)arg3;
+ (id)_nonInstancedOperationsFromComposition:(id)arg1;
+ (bool)_operationIsBrushStroke:(id)arg1;
+ (bool)_regionSupportsObjectRemoval;
+ (struct { struct { long long x_1_1_1; long long x_1_1_2; } x1; struct { long long x_2_1_1; long long x_2_1_2; } x2; })_tightImageSpaceBoundsForOperation:(id)arg1 composition:(id)arg2 error:(out id*)arg3;
+ (bool)brushStrokeExceedsSizeLimit:(id)arg1 imageSize:(struct CGSize { double x1; double x2; })arg2 closeAndFillStroke:(bool)arg3;
+ (void)createAvailableObjectsMaskForContext:(id)arg1 composition:(id)arg2 completion:(id /* block */)arg3;
+ (void)createDeclutterMaskForContext:(id)arg1 composition:(id)arg2 completion:(id /* block */)arg3;
+ (void)createMaskContextForComposition:(id)arg1 requestID:(id)arg2 completionQueue:(id)arg3 completion:(id /* block */)arg4;
+ (id)createMaskForInstance:(unsigned long long)arg1 context:(id)arg2 maskIdentifierPrefix:(id)arg3 error:(out id*)arg4;
+ (void)createSubjectMaskForContext:(id)arg1 composition:(id)arg2 completion:(id /* block */)arg3;
+ (bool)deviceSupportsObjectRemoval;
+ (struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })inflatedFaceRect:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg1 imageOrientation:(long long)arg2;
+ (void)initialize;
+ (bool)loadAndRegisterInpaintModel:(out id*)arg1;
+ (bool)loadAndRegisterModelForKey:(id)arg1 error:(out id*)arg2;
+ (bool)loadAndRegisterRefinementModel:(out id*)arg1;
+ (bool)mask:(id)arg1 containsPoint:(struct CGPoint { double x1; double x2; })arg2;
+ (bool)mask:(id)arg1 intersectsDiskWithOrigin:(struct CGPoint { double x1; double x2; })arg2 radius:(double)arg3;
+ (id)maskIdentifierForSegmentIndex:(unsigned long long)arg1;
+ (id)maskIdentifierForSegmentIndices:(id)arg1;
+ (bool)maskIdentifierIsDeclutter:(id)arg1;
+ (bool)maskIsMostlyWithinFace:(id)arg1 imageSize:(struct { long long x1; long long x2; })arg2 imageOrientation:(long long)arg3 detectedFaces:(id)arg4;
+ (bool)objectMasksExceedSizeLimit:(id)arg1 imageSize:(struct CGSize { double x1; double x2; })arg2;
+ (id)privateCreateMaskForInstance:(unsigned long long)arg1 context:(id)arg2 maskIdentifierPrefix:(id)arg3 error:(out id*)arg4;
+ (void)purgeIntermediateInpaintCaches;
+ (id)removeGatedInstances:(id)arg1 context:(id)arg2;
+ (id)removeInstancesOccludedByOperations:(id)arg1 fromInstances:(id)arg2 composition:(id)arg3 maskContext:(id)arg4;
+ (id)removeOperationsFromInstances:(id)arg1 composition:(id)arg2 context:(id)arg3;
+ (bool)strokeIsEntirelyWithinFace:(id)arg1 imageSize:(struct { long long x1; long long x2; })arg2 imageOrientation:(long long)arg3 detectedFaces:(id)arg4;
+ (void)updateMaskContext:(id)arg1 forComposition:(id)arg2 requestID:(id)arg3 completionQueue:(id)arg4 completion:(id /* block */)arg5;
+ (void)warmUpResources;

@end
